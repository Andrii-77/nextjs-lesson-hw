import {NextRequest, NextResponse} from "next/server";
import {headers} from "next/headers";

// export const middleware = (request: NextRequest) => {
//     console.log('middleware');
// }

 // Функція middleware - це є прошарок, який буде працювати на кожну урлу, на данному етапі. Щось він може
// перевіряти: ваші куки, ваші боді, ваші хедери, урли ітд., тобто ту метаінформацію, до якої ми напряму немаємо
// доступу зазвичай (намагаємось не доступатись, яка клієнту (користувачеві сайту) невидима). Вона може щось з цієї
// інф-ії брати, виконувати і продовжувати запит. Це схоже на інтерцептор.
// middleware працює завжди, на будь-яку урлу, на яку б ви не перейшли. Якщо б вам треба було, щоб middleware
// працював на конкертну урлу, то доведеться зробити таку штуку як конфіг: ви експортуєте обєкт конфіг і в ньому
// вказуєте або регулярний вираз, або конретні урли, на які він повинен реагувати:

// export const config = {
//     // matcher: '/about/:path*',  // тут буде реагувати на урлу слеш ебаут слеш щось та там, а може бути тире щось та
//                                // там. /about/jkdsahvsdfbvjhnsdf-61614156
//     matcher: '/auth'
// }

// Це можна викор-ти як прошарок для аутентифікації і локалізації. Його викор-ють щоб брати якусь інф-ію з кук і на
// її основі щось робити. А в куках зазвичай зберігаються токени, інф-ія про локалізації (в декого це зберігається в
// локалСтореджі). Як це можна зробити: з request (це той реквест, який він перехоплює), тобто ви робите запит до
// певної точки, якщо ви переходите на сторінку '/auth', то відпровідно цей реквест буде на цю сторінку, зі всіма
// його похідними і вихідними додатковими метаданими, зокрема з куками:
// Потім на основі логіну і пасворду ми робимо кудись (потенційно це може бути сервер, який формує токени) постовий
// фетч-запит, в якому передаємо логін і пароль:
// Після цього ви отримаєте наприклад якусь відповідь і ця відповідь буде вашим токеном: (зараз ці дії не будуть
// виконані, бо немає жодного сервера який зараз зміг би допомогти, тому це просто закоментуємо:
// Просто зформуємо токен, який в собі буде мати набір символів: Відповідно зробили якісь дії, сказали, що функ-я
// реагує тільки на '/auth', і після цього зформувався токен, нам його прислали. Тепер цей токен ми будемо додавати
// до кожного реквесту, який у нас буде здійснюватись в майбутньому. Щоб цим токеном поділитись з клієнтом, потрібно
// відправити його: return response. Обєкт response формуєтья за допомогою NextResponse.next(); В дужках можуть бути
// ініцілізаційні дані: хедери. Скажемо хедер -> ауторізейшн зі значенням нашого токена. І це вже сформує обект,
// який ми назвемо response.
// В постмені ми робимо сенд на http://localhost:3000/auth, запит перехоплюється, і у хедерах нашої відповіді,
// нашого респонсу на цей запит, є хедер, який наз-ся Authorization зі значенням 'bgfb6516dbdgb531dbgfn5'. Далі наша
// клієнтська частина може кудись його зберегти (куки, локалСторідж, змінна, сешнСторідж (це залежить від підходу,
// який обрали девелопери)), і далі всі запити робить із ним.
// Можуть бути урли слеш аус слеш щось та там ('/auth/:path'), без різниці що, і тоді ви будете їх відхоплювати і
// перевіряти, чи містять вони вже цей токен. І якщо містять, то відповідно тоді можна робити запит до сервіса, який
// робить запит на отримання якоїсь певної інф-ії, зокрема і на ваш роутХендлер.
// Так само з кукі можна отримати інф-ію, яка локалізація в людини на вашому сайті вибрана (ENG, UA, PL ітд) і на
// основі цієї інф-ії також підтягувати якусь інф-ію.
// Що один момент. У response теж присутнє боді, яке ви теж можете наповнювати, якщо вам знадобиться передавати
// інф-ію. Зробити це можна звертаючись до спеціальної ф-ії, яка наз-ся некст. Коментуємо const token і const
// response. Робимо обєкт NextResponse, в середину якого можна покласти боді. Нехай це буде бєлєбєрдятіна. І також
// сюди можна покласти хар-ку хедерс: три ікса зі значенням чотири ігрека. Перевіримо в постмені на урлі '/auth'.
// Доданий хедер є. Боді 'fhbgfbgfnbg' також існує. Тобто звідси можна дістати вже всю інф-ію, яка вам тільки
// необідна на етапі, коли ви отримали відповідь.
// На цьому етапі можна отримати зі сторонніх джерел будь-яку інф-ію і викор-ти її. Напр. можна зробити перевірку: у
// випадку якщо локаль (витягнути з кук хар-ку локалізації) буде еквівалентна значенню інгліш, то відповідно вам
// потрібно зробити фетч-запит на якусь урлу, яка дістане англійський контент.
// Також в return new NextResponse ви можете сказати куди ви хочете редіректити цю всю штуку: ('fhbgfbgfnbg',
// {headers: {'xxx': 'yyyy'}, url}) - поставити урлу яка буде. Це прошарок, який більш цікавий для нас.
// Все коментуємо в {} middleware.
// Що робити, якщо на одну урлу потрібна одна логіка, а на іншу урлу - інша логіка? Для цього моменту ми не
// викор-ємо config (коментуємо його). Далі працюємо ВИКЛЮЧНО    іфами, як би кастильно це не виглядало. І ви будете
// перевіряти реквест, його юрл, якщо воно починається/містить щось ітд, то ви робите якусь дію одну. Далі есл, іф,
// реквест ваш юрл - то відповідно ви робите якусь іншу дію, ітд ітд. В загальному існує бібліотека nemo, яка
// дозволяє конфігурувати всю цю штуку в форматі стороння ф-ія крапка, стороння ф-ія крапка, тобто чейнінг варіант.
// Її не сильно полюбляють, бо вона ще не доведена до діла (до розуму). Вона дозволяє позбавитись від іф/елсе. Але
// іф/елсе це цілком адекватна ситуація, вони є в офіційній документації.

export const middleware = async (request: NextRequest) => {
    // console.log('middleware');

    // const login = request.cookies.get('login');
    // const password = request.cookies.get('password');
    // const token = await fetch('YOURURL', {
    //     method: 'POST',
    //     headers: {
    //         'Accept': 'application/json',
    //         'Content-Type': 'application/json',
    //     },
    //     body: JSON.stringify({
    //         key1: login,
    //         key2: password,
    //     })
    // })
    //     .then(value => value.json());

    // const token = 'bgfb6516dbdgb531dbgfn5';

    // const response = NextResponse.next({
    //     headers: {
    //         Authorization: token
    //     }
    // });
    // return response;

    // if (locale === 'EN'){
    //     fetch // content
    // }
    //
    // return new NextResponse('fhbgfbgfnbg', {headers: {'xxx': 'yyyy'}})

    if(request.url.startsWith("/api/")){
        //some action
    }else if(request.url.startsWith("/swapi/")){
        //.....
    }
}

// export const config = {
//     matcher: '/auth'
// }

