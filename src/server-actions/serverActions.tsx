'use server';
// наступне треба буде рознести по іншихи фалах:
import sql from "better-sqlite3";
import {revalidatePath} from "next/cache";

const db = sql('meals.db');

export const saveMeal = async (formData: FormData) => {
    //FormData  - дані з форми.
    // console.log(formData);
    // console.log("saveAction")
    //fetch post
    //do some stuff
    //add data to database (db) - про цей момент поговоримо.

//     дістаємо з FormData інф-ію:
    const titleValue = formData.get('title');
//     titleValue - інф-ія з інпуту. Тепер, щоб запхати цю інф-ію в базу даних:
    db.prepare(`insert into meals(title)
                values (?)`)
        .run(titleValue);
//     якщо ви захочете, після того як ви зберегли якусь інф-ію, переходити на якусь сторінку, існує ф-ія:
//     redirect('урла куди хочете перейти')
//     Але є нюанс, якщо ви хочете залишитись на тій самій сторінці де заповнюєте форму, то буде проблема, йдемо на
//     цю сторінку.

//     Для рендіренгу (перезавантаження сторінки), щоб зявилась нововведена інфа з інпуту,  існує дія:
    revalidatePath('/');
//     де ви кажете, що після того, як ви зберігаєете інф-ію в БД, ви повинні всі дані (всю інф-ію) по цьому шляху
//     ('/') ревалідувати, тобто стверджувати, що є зміни, і цей шлях треба ревалідовувати.
//     Відповідно тепер після запису робиться 2 дії: запис в БД і другою казати, що той шлях, на якому я знаходжусь
//     потребує ревалідації (перезавантаження) (перевірки на наявність змін, і якщо вони є - вони відобразяться).
//     Якщо ви захочете відправляти дані не напраму в БД, а на якийсь сервер, в якого є свій АРІ, то ви спокійно
//     робите тут фетчовий запит (постовий запит).
//     Так виглядає робота з формами і зміна даних в next-і.
}

type Meal = { id: number, title: string };

// робимо ф-ію, яка буде звязуватись з БД і діставати звідти всі meals
export const getMeals = async (): Promise<Meal[]> => {
    return db.prepare<Meal[]>('select * from meals').all() as Meal[];
}